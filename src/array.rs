// 固定长度 Array
// 动态长度 Vector

// 数组三要素
// 长度固定
// 元素必须有相同的类型
// 依次线性排列

// 要点总结
// 数组类型容易跟数组切片混淆，[T;n]描述了一个数组的类型，而[T]描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用[T;n]的形式去描述、
// [u8; 3]和[u8; 4]是不同的类型，数组的长度也是类型的一部分
// 在实际开发中，使用最多的是数组切片[T]，我们往往通过引用的方式去使用&[T]，因为后者有固定的类型大小
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];
    // 声明类型及长度 [类型；长度]
    let a1: [i32; 5] = [1, 2, 3, 4, 5];
    // [类型;长度] 声明一个长度为5，使用3来填充的 Array
    let a2 = [3; 5];

    // 访问元素
    // 因为数组是连续存放元素的、所以可以通过索引来获取元素
    let a0 = a[0];

    println!("{:?}{:?}{:?}", a0, a1, a2);

    // 数组切片
    // 切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置
    // 创建切片的代价非常小，因为切片只是针对底层数组的一个引用
    // 切片类型[T]拥有不固定的大小，而切片引用类型&[T]则具有固定的大小，
    // 因为 Rust 很多时候都需要固定大小数据类型，因此&[T]更有用,&str字符串切片也同理
    let s: &[i32] = &a[..2];
    println!("slice {:?}", s);

    // 越界访问case
    println!("请输入一个数组Index");

    let mut index = String::new();

    io::stdin().read_line(&mut index).expect("输入异常");

    let index: usize = index.trim().parse().expect("解析异常");

    // 越界访问
    // panic 造成程序崩溃
    // 当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，
    // Rust 会出现 panic。这种检查只能在运行时进行，比如在上面这种情况下，编译器无法在编译期知道用户运行代码时将输入什么值。
    // 这种就是 Rust 的安全特性之一。在很多系统编程语言中，并不会检查数组越界问题，你会访问到无效的内存地址获取到一个风马牛不相及的值，最终导致在程序逻辑上出现大问题，而且这种问题会非常难以检查。
    let ele = a[index];

    println!("find index {} is {}", index, ele);
}
