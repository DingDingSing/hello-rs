#![allow(unused)]
fn main() {
    let x = 10;
    // & 引用
    let y = &x;
    // *y 解引用
    assert_eq!(x, *y);

    let c = String::from("hello");
    // 传递引用 并不转移所有权
    // & 符号即是引用，它们允许你使用值，但是不获取所有权
    let len = get_len(&c);
    println!("{} is {}", c, len);

    // 可变引用
    // 可变引用同时只能存在一个
    let mut d = String::from("d hello");
    add_len(&mut d);
    println!("d is {}", d);

    // 同一作用域，特定数据只能有一个可变引用
    // 下面会提示异常
    // 这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：
    //      两个或更多的指针同时访问同一数据
    //      至少有一个指针被用来写入数据
    //      没有同步数据访问的机制
    // 数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。
    let d1 = &mut d;
    let d2 = &mut d;
    // println!("d1 is {} , d2 is {}", d1, d2);

    // 作用域可以在一定程度上解决问题
    {
        let d3 = &mut d;
    }

    // 可变引用与不可变引用不能同时存在
    // 以下代码会抛出 panic
    // 正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。
    // 多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。
    let d4 = &d;
    let d5 = &mut d;
    // println!("d4 is {},d5 is {}", d4, d5);

    // 作用域问题
    // 在老版本的编译器中（Rust 1.31 前），将会报错，因为 r1 和 r2 的作用域在花括号 } 处结束，
    // 那么 r3 的借用就会触发 无法同时借用可变和不可变的规则。
    // 但是在新的编译器中，该代码将顺利通过，因为 引用作用域的结束位置从花括号变成最后一次使用的位置，
    // 因此 r1 借用和 r2 借用在 println! 后，就结束了，此时 r3 可以顺利借用到可变引用。
    let r1 = &d;
    let r2 = &d;
    println!("{} and {}", r1, r2);
    // 新编译器中，r1,r2作用域在这里结束
    // 下面不会抛出异常 由于后续 r1 r2 不再使用，已经结束作用域。

    let r3 = &mut d;
    println!("{}", r3);
    // 老编译器中，r1、r2、r3作用域在这里结束
    // 新编译器中，r3作用域在这里结束
    // NLL
    // 对于这种编译器优化行为，Rust 专门起了一个名字 —— Non-Lexical Lifetimes(NLL)，
    // 专门用于找到某个引用在作用域(})结束前就不再被使用的代码位

    // 悬垂引用(Dangling References)
    // 悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，
    // 其指向的内存可能不存在任何值或已被其它变量重新使用。
    // 在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，
    // 编译器可以确保数据不会在其引用之前被释放，要想释放数据，必须先停止其引用的使用。
    // 当 dangle 的代码执行完毕后，s 将被释放, 但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 String
    let dangling_pointer = dangling_references();
}

fn dangling_references() -> &String {
    let s = String::from("hello dangle");
    &s
}
// 这里 s 离开作用域并被丢弃。其内存被释放。

fn add_len(s: &mut String) {
    s.push_str(" d world")
}

fn get_len(s: &String) -> usize {
    s.len()
}


// 借用规则如下
// 1. 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
// 2. 引用必须总是有效的
